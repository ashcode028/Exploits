# Stack-based Buffer-Overflow

Class: CSE544
Name:: Ashita
Roll No: 2019028
Type: Assignment 2

# Steps to replicate the exploit

## Step 1: **Preparing the shellcode**

This is a basic assembly program to print “Finally Hacked”. You can use any program as per your convenience but make sure it doesn't have null characters as the stack always places a null character to end the buffer, so it would stop your program before completion itself.

`nasm -felf64 shell.asm && ld shell.o -o shell`  

`for i in $(objdump -d shell |grep "^ " |cut -f2); do echo -n '\x'$i; done; echo`

Paste the above output in the exploit script you will create.

## Step 2: Finding buffer size and start address

> Download the victim stack and then give yourself execute permissions using `chmod +x`
> 
1. Open gdb 
    1.  `gdb ./victim-exec-stack`
2. Add a breakpoint in main and just before exiting the code using  these commands in order
    1. `break main`
    2. `run`
    3. `disass main`
    4. `break *<leaveq>`
    5. `c`
    
    ![Screenshot from 2022-03-09 11-37-10.png](Stack-based%20Buffer-Overflow%20583fc2e848e44213b2d04b60082ed672/Screenshot_from_2022-03-09_11-37-10.png)
    
3. Now find the start of the buffer using `x/80x $rsp` after the first breakpoint.
    
    The first address (in blue color) is the required address where we need to inject the shellcode
    
    ![Screenshot from 2022-03-09 11-45-31.png](Stack-based%20Buffer-Overflow%20583fc2e848e44213b2d04b60082ed672/Screenshot_from_2022-03-09_11-45-31.png)
    
    Here to verify the assumed stack address is correct or not, I  have checked the first 80 bytes of rsp after the first breakpoint to see the dummy payload(52 A’s) we are sending is pointing to the assumed stack address or not.
    
    We can clearly see 0x41 is the hex value of A is`0x7fffffffdd70`
    
4. Now find rip using `info frame`
    
    ![Screenshot from 2022-03-09 12-16-29.png](Stack-based%20Buffer-Overflow%20583fc2e848e44213b2d04b60082ed672/Screenshot_from_2022-03-09_12-16-29.png)
    
    We can see the value of RIP in the saved registers. Once we subtract the base address which we got just before this with the RIP value, we get the buffer size. Hence the ***size of the buffer is 72.***
    

## Step 4: Preparing payload code

Open any text editor and then send a string having shellcode in it as shown below.

![Screenshot from 2022-03-09 12-26-22.png](Stack-based%20Buffer-Overflow%20583fc2e848e44213b2d04b60082ed672/Screenshot_from_2022-03-09_12-26-22.png)

Major work is done by these two lines of code only

> RIP = struct.pack("Q", (0x7fffffffdd70 +72)+8)
payload = "\x90"*72 + RIP + "\x90"*12 + shellcode
> 

*Payload, we sent 72 NOPs to overflow the buffer address, then RIP will point to the base of the stack, then we overwrite it again by a few NOPs, and then the shellcode will be executed and will be exiting the code using the shellcode written by us.*

*RIP is calculated by adding the base address of stack + size of the buffer and the RIP instruction itself which is 8bytes so this will directly point to the shellcode now.*

The above script would write the payload into a file called output. Its contents would like shown below

![Screenshot from 2022-03-09 12-26-44.png](Stack-based%20Buffer-Overflow%20583fc2e848e44213b2d04b60082ed672/Screenshot_from_2022-03-09_12-26-44.png)

## Step 5: Injecting shellcode in the stack

Run the commands in order 

`run < output`

`c`

`x/120x $rsp`

`c`

![Screenshot from 2022-03-09 11-57-06.png](Stack-based%20Buffer-Overflow%20583fc2e848e44213b2d04b60082ed672/Screenshot_from_2022-03-09_11-57-06.png)

We sent the buffer to be NOPs til it is overflowed. As mentioned above we overwrite it again with a few NOPs and then the shellcode will be written. Thus, the contents of the buffer at the first breakpoint would be NOPs and then the second time would be the contents of our shellcode.

Thus, we can see “Finally Hacked” being printed and it exited normally through our shellcode.

### Other points to be noted

1. All the steps mentioned were done in GDB so that the address of the stack pointer remains the same. We can perform step 5 outside the gdb if the stack randomization is turned off.
2. The above method is not the only method, other method is when we don't overflow the buffer with NOPs but with our shellcode and some padding. Then we send the payload as padding with shellcode followed with some Nops which has a total size equal to the buffer size so that the next instruction pointed is directed to the base of the stack again. So we see the contents of our shellcode twice.
    
    > RIP = struct.pack("Q", 0x7fffffffdd70)
    padding = "\x90" * 8
    nops= "\x90" * 12
    payload= padding + shellcode + nops + RIP
    > 
    
    ![Screenshot from 2022-03-09 12-57-57.png](Stack-based%20Buffer-Overflow%20583fc2e848e44213b2d04b60082ed672/Screenshot_from_2022-03-09_12-57-57.png)
    
3. Make file consists of steps to compile and run shellcode and assembly files. To run a python script and object dump along with it uncomment the code as required.

### Submitted files

1. *run_shellcode.c* → c code to run shellcode generated by the assembly code through C program
2. *exploit.py* → Python script to generate payload to inject in the victim stack
3. *shell.asm* → assembly file to print “Finally Hacked”
4. *Makefile* → To run *shell.asm* and *run_shellcode.c*
5. *Writeup.pdf* → Explaination of the exploit and its replication

### References:

[https://www.tallan.com/blog/2019/04/04/exploring-buffer-overflows-in-c-part-two-the-exploit/](https://www.tallan.com/blog/2019/04/04/exploring-buffer-overflows-in-c-part-two-the-exploit/)

[https://0xrick.github.io/binary-exploitation/bof5/](https://0xrick.github.io/binary-exploitation/bof5/)

[https://www.youtube.com/watch?v=_nwkiTxtDbk&t=30s](https://www.youtube.com/watch?v=_nwkiTxtDbk&t=30s)

[https://www.youtube.com/watch?v=oS2O75H57qU](https://www.youtube.com/watch?v=oS2O75H57qU)

[https://samsclass.info/127/proj/p3-lbuf1.htm](https://samsclass.info/127/proj/p3-lbuf1.htm)

[https://dhavalkapil.com/blogs/Shellcode-Injection/](https://dhavalkapil.com/blogs/Shellcode-Injection/)

[https://in-addr.nl/mirror/www.madirish.net/142.html](https://in-addr.nl/mirror/www.madirish.net/142.html)

[https://www.rapid7.com/blog/post/2019/02/19/stack-based-buffer-overflow-attacks-what-you-need-to-know/](https://www.rapid7.com/blog/post/2019/02/19/stack-based-buffer-overflow-attacks-what-you-need-to-know/)

[http://security.cs.pub.ro/hexcellents/wiki/kb/exploiting/shellcode-walkthrough](http://security.cs.pub.ro/hexcellents/wiki/kb/exploiting/shellcode-walkthrough)

[https://www.tenouk.com/Bufferoverflowc/Bufferoverflow4.html](https://www.tenouk.com/Bufferoverflowc/Bufferoverflow4.html)

[https://resources.infosecinstitute.com/topic/how-to-exploit-buffer-overflow/](https://resources.infosecinstitute.com/topic/how-to-exploit-buffer-overflow/)